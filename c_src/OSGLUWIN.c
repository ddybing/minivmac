/*
	OSGLUWIN.c

	Copyright (C) 2001 Philip Cummins, Weston Pawlowski,
	Bradford L. Barrett, Paul Pratt

	You can redistribute this file and/or modify it under the terms
	of version 2 of the GNU General Public License as published by
	the Free Software Foundation.  You should have received a copy
	of the license along with with this file; see the file COPYING.

	This file is distributed in the hope that it will be useful,
	but WITHOUT ANY WARRANTY; without even the implied warranty of
	MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
	license for more details.
*/

/*
	Operating System GLUe for WINdows.

	All operating system dependent code for the
	Microsoft Windows platform should go here.

	This code is descended from Weston Pawlowski's Windows
	port of vMac, by Philip Cummins.
	The function jdate is from the program Webalizer
	by Bradford L. Barrett.

	The main entry point 'WinMain' is at the end of this file.
*/

#include "SYSDEPNS.h"

#ifndef WinTarget
#define WinTarget 0
#endif

#if WinTarget /* This entire file is for Windows only */

#ifndef HaveOSTarget
#error "HaveOSTarget undefined"
#endif

#include "OSGLUWIN.h"

#include "OSGIMPRT.h"
#include "RESIDWIN.h"

/* ignore warnings generated by system includes */
#pragma warning(disable : 4142 4201 4214 4115)

#include <windows.h>
#include <time.h>

/* turn warnings back on */
#pragma warning(default : 4142 4201 4214 4115)

#define InstallFileIcons 1

/*--- some simple utilities ---*/

#define PowOf2(p) ((unsigned long)1 << (p))
#define TestBit(i, p) (((unsigned long)(i) & PowOf2(p)) != 0)

void MyMoveBytes(anyp srcPtr, anyp destPtr, LONG byteCount)
{
/*
	must work even if blocks overlap in memory
*/
	(void) memcpy((char *)destPtr, (char *)srcPtr, byteCount);
}

/*--- basic dialogs ---*/

static HWND MainWnd;

void MacMsg(char *briefMsg, char *longMsg, blnr fatal)
{
	UnusedParam(fatal);
	MessageBox(MainWnd, longMsg, briefMsg, MB_APPLMODAL|MB_OK);
}

blnr OkCancelAlert(char *briefMsg, char *longMsg)
{
	return (IDOK==MessageBox(MainWnd, longMsg, briefMsg, MB_APPLMODAL|MB_OKCANCEL|MB_ICONWARNING|MB_DEFBUTTON2));
}

/*--- main window ---*/

static HINSTANCE AppInstance;
static HDC MainWndDC;

static int KeyMod=0;
static BYTE KeyDown=0;
static LONG CmdShow;

static int WndX;
static int WndY;

static char *WndTitle = "Mini vMac";
static char *WndClassName = "minivmac";

static blnr CreateMainWindow(void)
{
	int XBorder = GetSystemMetrics(SM_CXFIXEDFRAME);
	int YBorder = GetSystemMetrics(SM_CYFIXEDFRAME);
	int YCaption = GetSystemMetrics(SM_CYCAPTION);
	int YMenu = GetSystemMetrics(SM_CYMENU);
	int XSize = XBorder + vMacScreenWidth + XBorder;
	int YSize = YBorder + YCaption + YMenu + vMacScreenHeight + YBorder;
	int ScreenX = GetSystemMetrics(SM_CXSCREEN);
	int ScreenY = GetSystemMetrics(SM_CYSCREEN);

	WndX = (ScreenX - XSize) / 2;
	WndY = (ScreenY - YSize) / 2;

	if (WndX<0) {
		WndX=0;
	}
	if (WndY<0) {
		WndY=0;
	}

	MainWnd = CreateWindow(WndClassName, WndTitle,
		WS_VISIBLE|WS_SYSMENU|WS_MINIMIZEBOX,
		WndX, WndY, XSize, YSize, NULL,
		LoadMenu(AppInstance, MAKEINTRESOURCE(IDR_MAINMENU)),
		AppInstance, NULL);
	if (MainWnd == NULL) {
		MacMsg("CreateWindow failed", "Sorry, vMac encountered errors and cannot continue.", trueblnr);
	} else {
		ShowWindow(MainWnd, CmdShow);
		MainWndDC = GetDC(MainWnd);
		if (MainWndDC == NULL) {
			MacMsg("GetDC failed", "Sorry, vMac encountered errors and cannot continue.", trueblnr);
		} else {
			return trueblnr;
		}
	}
	return falseblnr;
}

static blnr AllocateScreenCompare(void)
{
	screencomparebuff = (char *)GlobalAlloc(GMEM_FIXED, vMacScreenNumBytes);
	if (screencomparebuff == NULL) {
		MacMsg("Not enough memory", "There is not enough memory available to allocate the screencomparebuff.", trueblnr);
		return falseblnr;
	} else {
		return trueblnr;
	}
}

typedef struct BITMAPINFOHEADER256 {
	BITMAPINFOHEADER bmi;
	RGBQUAD colors[2];
} BITMAPINFOHEADER256;

static void Screen_DrawAll(void)
{
	BITMAPINFOHEADER256 bmh;

	memset (&bmh, sizeof (bmh), 0);
	bmh.bmi.biSize = sizeof(BITMAPINFOHEADER);
	bmh.bmi.biWidth = vMacScreenWidth;
	bmh.bmi.biHeight = -vMacScreenHeight;
	bmh.bmi.biPlanes = 1;
	bmh.bmi.biBitCount = 1;
	bmh.bmi.biCompression= BI_RGB;
	bmh.bmi.biSizeImage = 0;
	bmh.bmi.biXPelsPerMeter = 0;
	bmh.bmi.biYPelsPerMeter = 0;
	bmh.bmi.biClrUsed = 0;
	bmh.bmi.biClrImportant = 0;
	bmh.colors[0].rgbRed = 255;
	bmh.colors[0].rgbGreen = 255;
	bmh.colors[0].rgbBlue = 255;
	bmh.colors[0].rgbReserved = 0;
	bmh.colors[1].rgbRed = 0;
	bmh.colors[1].rgbGreen = 0;
	bmh.colors[1].rgbBlue = 0;
	bmh.colors[1].rgbReserved = 0;
	if (SetDIBitsToDevice(
		MainWndDC, /* handle of device context */
		0, /* x-coordinate of upper-left corner of dest. rect. */
		0, /* y-coordinate of upper-left corner of dest. rect. */
		vMacScreenWidth, /* source rectangle width */
		vMacScreenHeight, /* source rectangle height */
		0, /* x-coordinate of lower-left corner of source rect. */
		0, /* y-coordinate of lower-left corner of source rect. */
		0, /* first scan line in array */
		vMacScreenHeight, /* number of scan lines */
		(CONST VOID *)screencomparebuff, /* address of array with DIB bits */
		(const struct tagBITMAPINFO *)&bmh, /* address of structure with bitmap info. */
		DIB_RGB_COLORS /* RGB or palette indices */
	) == 0) {
		/* ReportWinLastError(); */
	}
}

void HaveChangedScreenBuff(WORD top, WORD left, WORD bottom, WORD right)
{
	BITMAPINFOHEADER256 bmh;
	UBYTE *p = ((UBYTE *)screencomparebuff) + top * (vMacScreenWidth >> 3);

	UnusedParam(left);
	UnusedParam(right);
#if 0
	{ /* testing code */
		if (PatBlt(MainWndDC,
			(int)left - 1,
			(int)top - 1,
			(int)right-left + 2,
			(int)bottom-top + 2, PATCOPY)) {
		}
	}
#endif
	memset (&bmh, sizeof (bmh), 0);
	bmh.bmi.biSize = sizeof(BITMAPINFOHEADER);
	bmh.bmi.biWidth = vMacScreenWidth;
	bmh.bmi.biHeight = -(bottom - top);
	bmh.bmi.biPlanes = 1;
	bmh.bmi.biBitCount = 1;
	bmh.bmi.biCompression= BI_RGB;
	bmh.bmi.biSizeImage = 0;
	bmh.bmi.biXPelsPerMeter = 0;
	bmh.bmi.biYPelsPerMeter = 0;
	bmh.bmi.biClrUsed = 0;
	bmh.bmi.biClrImportant = 0;
	bmh.colors[0].rgbRed = 255;
	bmh.colors[0].rgbGreen = 255;
	bmh.colors[0].rgbBlue = 255;
	bmh.colors[0].rgbReserved = 0;
	bmh.colors[1].rgbRed = 0;
	bmh.colors[1].rgbGreen = 0;
	bmh.colors[1].rgbBlue = 0;
	bmh.colors[1].rgbReserved = 0;
	if (SetDIBitsToDevice(
		MainWndDC, /* handle of device context */
		0, /* x-coordinate of upper-left corner of dest. rect. */
		top, /* y-coordinate of upper-left corner of dest. rect. */
		vMacScreenWidth, /* source rectangle width */
		(bottom - top), /* source rectangle height */
		0, /* x-coordinate of lower-left corner of source rect. */
		0, /* y-coordinate of lower-left corner of source rect. */
		0, /* first scan line in array */
		(bottom - top), /* number of scan lines */
		(CONST VOID *)p, /* address of array with DIB bits */
		(const struct tagBITMAPINFO *)&bmh, /* address of structure with bitmap info. */
		DIB_RGB_COLORS /* RGB or palette indices */
	) == 0) {
		/* ReportWinLastError(); */
	}
}

static blnr CurTrueMouseButton = falseblnr;

static blnr HaveCursorHidden = falseblnr;

static blnr InitTheCursor(void)
{
	SetCursor(LoadCursor(NULL,IDC_ARROW));
	return trueblnr;
}

static void ForceShowCursor(void)
{
	if (HaveCursorHidden) {
		HaveCursorHidden = falseblnr;
		(void) ShowCursor(TRUE);
		SetCursor(LoadCursor(NULL,IDC_ARROW));
	}
}

static void CheckMouseState(void)
{
	blnr ShouldHaveCursorHidden;
	blnr NewTrueMouseButton;
	POINT NewMousePos;

	GetCursorPos(&NewMousePos);
	NewMousePos.x -= WndX;
	NewMousePos.y -= WndY;

	NewTrueMouseButton = (GetAsyncKeyState(VK_LBUTTON) & 0x8000) != 0;

	ShouldHaveCursorHidden = trueblnr;
	if (NewMousePos.x < 0) {
		NewMousePos.x = 0;
		ShouldHaveCursorHidden = falseblnr;
	} else if (NewMousePos.x > vMacScreenWidth) {
		NewMousePos.x = vMacScreenWidth - 1;
		ShouldHaveCursorHidden = falseblnr;
	}
	if (NewMousePos.y < 0) {
		NewMousePos.y = 0;
		ShouldHaveCursorHidden = falseblnr;
	} else if (NewMousePos.y > vMacScreenHeight) {
		NewMousePos.y = vMacScreenHeight - 1;
		ShouldHaveCursorHidden = falseblnr;
	}

	if (NewTrueMouseButton != CurTrueMouseButton) {
		CurTrueMouseButton = NewTrueMouseButton;
		CurMouseButton = CurTrueMouseButton && ShouldHaveCursorHidden;
	}

	/* if (ShouldHaveCursorHidden || CurMouseButton) */
	/* for a game like arkanoid, would like mouse to still
	move even when outside window in one direction */
	{
		CurMouseH=NewMousePos.x;
		CurMouseV=NewMousePos.y;
	}

	if (HaveCursorHidden != ShouldHaveCursorHidden) {
		HaveCursorHidden = ShouldHaveCursorHidden;
		if (HaveCursorHidden) {
			(void) ShowCursor(FALSE);
		} else {
			(void) ShowCursor(TRUE);
			SetCursor(LoadCursor(NULL,IDC_ARROW));
		}
	}
}

/*
	Which key configuration do you want to use?
	1: Left control is command, right control is option.
	2: Alt is command, and control is option.
	3: (default) Left alt is command, right alt is option, and
		control is control.
*/
#define KeyConfig 3

static void Keyboard_UpdateKeyMap(int key, int down)
{
	UBYTE *kp = (UBYTE *)theKeys;

	if (key >= 0 && key < 64) {
		int bit = 1 << (key & 7);
		if (down) {
			kp[key / 8] |= bit;
		} else {
			kp[key / 8] &= ~bit;
		}
	}
}

static ULONG Win32KeyRemap(ULONG key, UWORD modifier)
{
	int Shift=modifier&0x0200;
	int Command=modifier&0x0100;
	int Option=modifier&0x0800;

	if (key>=0x41 && key<=0x5A && !Shift) { //unshifted letter keys
		return(key+0x20);
	}

	if (key==VK_SPACE) {
		return(key);
	}

	if (key>=0x41 && key<=0x5A && Shift && !Option && !Command) //shifted letter keys
		return(key);

	if (key>=0x30 && key<=0x39 && (!Shift || Option || Command)) //unshifted number keys
		return(key);

	if (key>=VK_NUMPAD0 && key<=VK_NUMPAD9) //Number pad
		return(key-0x30);

	if (key==VK_DELETE && KeyDown) //Macro for delete
	{
		PostMessage(MainWnd, WM_KEYUP,   VK_DELETE, 0);
		PostMessage(MainWnd, WM_KEYDOWN, VK_BACK, 0);
		PostMessage(MainWnd, WM_KEYUP,   VK_BACK, 0);

		return(0x1D); //Right arrow
	}

	if (key==VK_DECIMAL)
		return(0x2E);

	if (key==VK_ADD)
		return(0x2B);

	if (key==VK_SUBTRACT)
		return(0x2D);

	if (key==VK_MULTIPLY)
		return(0x2A);

	if (key==VK_DIVIDE)
		return(0x2F);

	if (key==VK_BACK)
		return(key);

	if (key==VK_RETURN)
		return(key);

	if (key==VK_TAB)
		return(key);

	if (key==VK_LEFT)
		return(0x1C);

	if (key==VK_RIGHT)
		return(0x1D);

	if (key==VK_UP)
		return(0x1E);

	if (key==VK_DOWN)
		return(0x1F);

	if (key==27) //ESC
		return(key);

	if (key==VkKeyScan('=') && !Shift)
		return(0x3D);

	if (key==VkKeyScan('=') && Shift)
		return(0x2B);

	if (key==VkKeyScan('-') && !Shift)
		return(0x2D);

	if (key==VkKeyScan('-') && Shift)
		return(0x5F);

	if (key==VkKeyScan(',') && !Shift)
		return(0x2C);

	if (key==VkKeyScan(',') && Shift)
		return(key);

	if (key==VkKeyScan('.') && !Shift)
		return(0x2E);

	if (key==VkKeyScan('.') && Shift)
		return(key);

	if (key==VkKeyScan('`') && !Shift)
		return(0x60);

	if (key==VkKeyScan('`') && Shift)
		return(0x7E);

	if (key==VkKeyScan('\'') && !Shift)
		return(0x27);

	if (key==VkKeyScan('\'') && Shift)
		return(0x22);

	if (key==VkKeyScan(';') && !Shift)
		return(0x3B);

	if (key==VkKeyScan(';') && Shift)
		return(0x3A);

	if (key==VkKeyScan('0') && Shift)
		return(0x29);

	if (key==VkKeyScan('1') && Shift)
		return(0x21);

	if (key==VkKeyScan('2') && Shift)
		return(0x40);

	if (key==VkKeyScan('3') && Shift)
		return(0x23);

	if (key==VkKeyScan('4') && Shift)
		return(0x24);

	if (key==VkKeyScan('5') && Shift)
		return(0x25);

	if (key==VkKeyScan('6') && Shift)
		return(0x5E);

	if (key==VkKeyScan('7') && Shift)
		return(0x26);

	if (key==VkKeyScan('8') && Shift)
		return(0x2A);

	if (key==VkKeyScan('9') && Shift)
		return(0x28);

	if (key==VkKeyScan('/') && !Shift)
		return(0x2F);

	if (key==VkKeyScan('/') && Shift)
		return(key);

	if (key==VkKeyScan('\\') && !Shift)
		return(key);

	if (key==VkKeyScan('\\') && Shift)
		return(0x7C);

	if (key==VkKeyScan('[') && !Shift)
		return(key);

	if (key==VkKeyScan('[') && Shift)
		return(0x7B);

	if (key==VkKeyScan(']') && !Shift)
		return(key);

	if (key==VkKeyScan(']') && Shift)
		return(0x7D);

	return(0);
}

#define NotAfileRef NULL

static HANDLE Drives[NumDrives]; /* open disk image files */

static void InitDrives(void)
{
	WORD i;

	for (i = 0; i < NumDrives; ++i) {
		Drives[i] = NotAfileRef;
	}
}

WORD vSonyRead(void *Buffer, UWORD Drive_No, ULONG Sony_Start, ULONG *Sony_Count)
{
	WORD result;
	HANDLE refnum;
	DWORD newL;
	DWORD BytesRead = 0;

	if (Drive_No < NumDrives) {
		refnum = Drives[Drive_No];
		if (refnum != NotAfileRef) {
			newL = SetFilePointer(
				refnum, /* handle of file */
				Sony_Start, /* number of bytes to move file pointer */
				nullpr, /* address of high-order word of distance to move */
				FILE_BEGIN /* how to move */
			);
			if (newL == 0xFFFFFFFF) {
				result = -1; /*& figure out what really to return &*/
			} else if (Sony_Start != (ULONG)newL) {
				/* not supposed to get here */
				result = -1; /*& figure out what really to return &*/
			} else {
				if (! ReadFile(refnum, /* handle of file to read */
					(LPVOID)Buffer, /* address of buffer that receives data */
					(DWORD)*Sony_Count, /* number of bytes to read */
					&BytesRead, /* address of number of bytes read */
					nullpr)) /* address of structure for data */
				{
					result = -1; /*& figure out what really to return &*/
				} else if ((ULONG)BytesRead != *Sony_Count) {
					result = -1; /*& figure out what really to return &*/
				} else {
					result = 0;
				}
			}
		} else {
			result = 0xFFBF; // Say it's offline (-65)
		}
	} else {
		result = 0xFFC8; // No Such Drive (-56)
	}
	*Sony_Count = BytesRead;
	return result;
}

WORD vSonyWrite(void *Buffer, UWORD Drive_No, ULONG Sony_Start, ULONG *Sony_Count)
{
	WORD result;
	HANDLE refnum;
	DWORD newL;
	DWORD BytesWritten = 0;

	if (Drive_No < NumDrives) {
		refnum = Drives[Drive_No];
		if (refnum != NotAfileRef) {
			newL = SetFilePointer(
				refnum, /* handle of file */
				Sony_Start, /* number of bytes to move file pointer */
				nullpr, /* address of high-order word of distance to move */
				FILE_BEGIN /* how to move */
			);
			if (newL == 0xFFFFFFFF) {
				result = -1; /*& figure out what really to return &*/
			} else if (Sony_Start != (ULONG)newL) {
				/* not supposed to get here */
				result = -1; /*& figure out what really to return &*/
			} else {
				if (! WriteFile(refnum, /* handle of file to read */
					(LPVOID)Buffer, /* address of buffer that receives data */
					(DWORD)*Sony_Count, /* number of bytes to read */
					&BytesWritten, /* address of number of bytes read */
					nullpr)) /* address of structure for data */
				{
					result = -1; /*& figure out what really to return &*/
				} else if ((ULONG)BytesWritten != *Sony_Count) {
					result = -1; /*& figure out what really to return &*/
				} else {
					result = 0;
				}
			}
		} else {
			result = 0xFFBF; // Say it's offline (-65)
		}
	} else {
		result = 0xFFC8; // No Such Drive (-56)
	}
	*Sony_Count = BytesWritten;
	return result;
}

blnr vSonyDiskLocked(UWORD Drive_No)
{
	UnusedParam(Drive_No);
	return falseblnr;
}

WORD vSonyGetSize(UWORD Drive_No, ULONG *Sony_Count)
{
	WORD result;
	HANDLE refnum;
	DWORD L;

	if (Drive_No < NumDrives) {
		refnum = Drives[Drive_No];
		if (refnum != NotAfileRef) {
			L = GetFileSize (refnum, nullpr);
			if (L == 0xFFFFFFFF) {
				result = -1; /*& figure out what really to return &*/
			} else if (L < 0) {
				/* result doesn't fit in signed LongInt */
				result = -1; /*& figure out what really to return &*/
			} else {
				*Sony_Count = L;
				result = 0;
			}
		} else {
			result = 0xFFBF; // Say it's offline (-65)
		}
	} else {
		result = 0xFFC8; // No Such Drive (-56)
	}
	return result;
}

WORD vSonyEject(UWORD Drive_No)
{
	WORD result;
	HANDLE refnum;

	if (Drive_No < NumDrives) {
		refnum = Drives[Drive_No];
		if (refnum != NotAfileRef) {
			(void) FlushFileBuffers(refnum);
			(void) CloseHandle(refnum);
			result = 0;
			Drives[Drive_No] = NotAfileRef;
		}
		result = 0x0000;
	} else {
		result = 0xFFC8; // No Such Drive (-56)
	}
	return result;
}

WORD vSonyVerify(UWORD Drive_No)
{
	WORD result;

	if (Drive_No < NumDrives) {
		if (Drives[Drive_No] != NotAfileRef) {
			result = 0x0000; // No Error (0)
		} else {
			result = 0xFFBF; // Say it's offline (-65)
		}
	} else {
		result = 0xFFC8; // No Such Drive (-56)
	}
	return result;
}

WORD vSonyFormat(UWORD Drive_No)
{
	WORD result;

	if (Drive_No < NumDrives) {
		if (Drives[Drive_No] != NotAfileRef) {
			result = 0xFFD4; // Write Protected (-44)
		} else {
			result = 0xFFBF; // Say it's offline (-65)
		}
	} else {
		result = 0xFFC8; // No Such Drive (-56)
	}
	return result;
}

blnr vSonyInserted (UWORD Drive_No)
{
	if (Drive_No >= NumDrives) {
		return falseblnr;
	} else {
		return (Drives[Drive_No] != NotAfileRef);
	}
}

static blnr FirstFreeDisk(UWORD *Drive_No)
{
	WORD i;

	for (i = 0; i < NumDrives; ++i) {
		if (Drives[i] == NotAfileRef) {
			*Drive_No = i;
			return trueblnr;
		}
	}
	return falseblnr;
}

blnr AnyDiskInserted(void)
{
	WORD i;

	for (i = 0; i < NumDrives; ++i) {
		if (Drives[i] != NotAfileRef) {
			return trueblnr;
		}
	}
	return falseblnr;
}

static void Sony_Insert0(HANDLE refnum)
{
	UWORD Drive_No;

	if (! FirstFreeDisk(&Drive_No)) {
		(void) CloseHandle(refnum);
		MacMsg(kStrTooManyImagesTitle, kStrTooManyImagesMessage, falseblnr);
	} else {
		Drives[Drive_No] = refnum;
		MountPending |= ((ULONG)1 << Drive_No);
	}
}

static void Sony_Insert1(char *drivepath)
{
	HANDLE refnum = CreateFile(
		drivepath, /* pointer to name of the file */
		GENERIC_READ + GENERIC_WRITE, /* access (read-write) mode */
		0, /* share mode */
		nullpr, /* pointer to security descriptor */
		OPEN_EXISTING, /* how to create */
		FILE_ATTRIBUTE_NORMAL, /* file attributes */
		nullpr /* handle to file with attributes to copy */
	);
	if (refnum != INVALID_HANDLE_VALUE) {
		Sony_Insert0(refnum);
	}
}

static void InsertADisk(void)
{
	OPENFILENAME ofn;
	char szDirName[256];
	char szFile[256], szFileTitle[256];
	UINT  i, cbString;
	char  chReplace;
	char  szFilter[256];

	szDirName[0]='\0';
	szFile[0]='\0';
	strcpy(szFilter,"Disk images|*.DSK;*.HF?;*.IMG;*.IMA;*.IMAGE|All files (*.*)|*.*|\0");

	cbString=strlen(szFilter);

	chReplace = szFilter[cbString - 1];

	for (i = 0; szFilter[i] != '\0'; ++i)
	{
		if (szFilter[i] == chReplace)
			szFilter[i] = '\0';
	}

	memset(&ofn, 0, sizeof(OPENFILENAME));

	ofn.lStructSize = sizeof(OPENFILENAME);
	ofn.hwndOwner = MainWnd;
	ofn.lpstrFilter = szFilter;
	ofn.nFilterIndex = 1;
	ofn.lpstrFile= szFile;
	ofn.nMaxFile = sizeof(szFile);
	ofn.lpstrFileTitle = szFileTitle;
	ofn.nMaxFileTitle = sizeof(szFileTitle);
	ofn.lpstrInitialDir = szDirName;
	ofn.Flags = OFN_PATHMUSTEXIST | OFN_FILEMUSTEXIST | OFN_HIDEREADONLY;

	if(!GetOpenFileName(&ofn)) {
		/* report error */
	} else {
		Sony_Insert1(ofn.lpstrFile);
	}
}

static blnr GetAppDir (char* pathName)
/* be sure at least _MAX_PATH long! */
{
	if (GetModuleFileName (AppInstance, pathName, _MAX_PATH) == 0) {
		MacMsg("error", "GetModuleFileName failed", falseblnr);
	} else {
		char *p0 = pathName;
		char *p = nullpr;
		char c;

		while ((c = *p0++) != 0) {
			if (c == '\\') {
				p = p0;
			}
		}
		if (p == nullpr) {
			MacMsg("error", "strrchr failed", falseblnr);
		} else {
			*p = '\0';
			return trueblnr;
		}
	}
	return falseblnr;
}

static blnr MyReadDat(HANDLE refnum, ULONG L, void *p)
{
	DWORD BytesRead;

	if (! ReadFile(refnum, /* handle of file to read */
		(LPVOID)p, /* address of buffer that receives data */
		(DWORD)L, /* number of bytes to read */
		&BytesRead, /* address of number of bytes read */
		nullpr)) /* address of structure for data */
	{
		/*& should report the error *\&*/
		return falseblnr;
	} else if ((ULONG)BytesRead != L) {
		/*& should report the error *\&*/
		return falseblnr;
	} else {
		return trueblnr;
	}
}

static void MyWriteDat(HANDLE refnum, ULONG L, void *p)
{
	DWORD BytesWritten;

	if (! WriteFile(refnum, /* handle to file to write to */
		(LPVOID)p, /* pointer to data to write to file */
		(DWORD)L, /* number of bytes to write */
		&BytesWritten, /* pointer to number of bytes written */
		nullpr)) /* addr. of structure needed for overlapped I/O */
	{
		/*& should report the error *\&*/
	} else if ((ULONG)BytesWritten != L) {
		/*& should report the error *\&*/
	} else {
	}
}

static blnr AllocateMacROM(void)
{
	ROM = (UWORD *)GlobalAlloc(GMEM_FIXED, kROM_Size);
	if (ROM == NULL) {
		MacMsg("Not enough memory", "There is not enough memory available to allocate the ROM.", trueblnr);
		return falseblnr;
	} else {
		return trueblnr;
	}
}

static blnr LoadMacRom(void)
{
	char ROMFile[_MAX_PATH];
	HANDLE refnum;
	blnr IsOk = falseblnr;

	if (! GetAppDir(ROMFile)) {
		MacMsg("vMac error", "Sorry, vMac encountered errors and cannot continue.", trueblnr);
	} else {
		strcat(ROMFile, "vMac.ROM");

		refnum = CreateFile(
			ROMFile, /* pointer to name of the file */
			GENERIC_READ, /* access (read-write) mode */
			FILE_SHARE_READ, /* share mode */
			nullpr, /* pointer to security descriptor */
			OPEN_EXISTING, /* how to create */
			FILE_ATTRIBUTE_NORMAL, /* file attributes */
			nullpr /* handle to file with attributes to copy */
		);
		if (refnum == INVALID_HANDLE_VALUE) {
			MacMsg("vMac.ROM could not be found", "Read the ReadMe file before contacting us about this.", trueblnr);
		} else {
			if (! MyReadDat(refnum, kROM_Size, ROM)) {
				MacMsg("vMac error", "Couldn't read the ROM image file.", trueblnr);
			} else {
				IsOk = trueblnr;
			}
			(void) CloseHandle(refnum);
		}
	}
	return IsOk;
}

static blnr AllocateMacRAM(void)
{
	kRAM_Size = 0x00400000; // Try 4 MB
	RAM = (UWORD *)GlobalAlloc(GMEM_FIXED, kRAM_Size + RAMSafetyMarginFudge);
	if (RAM == NULL) {
		kRAM_Size = 0x00200000; // Try 2 MB
		RAM = (UWORD *)GlobalAlloc(GMEM_FIXED, kRAM_Size + RAMSafetyMarginFudge);
		if (RAM == NULL) {
			kRAM_Size = 0x00100000; // Try 1 MB
			RAM = (UWORD *)GlobalAlloc(GMEM_FIXED, kRAM_Size + RAMSafetyMarginFudge);
			if (RAM == NULL) {
				MacMsg("Not enough memory", "There is not enough memory available to allocate 1Mb of RAM for the emulated Mac.", trueblnr);
				return falseblnr;
			}
		}
	}

	return trueblnr;
}

static blnr SpeedLimit = falseblnr;

static blnr HogCPU = trueblnr;

static blnr RTC_Load (void)
{
	char PramFile[_MAX_PATH];
	HANDLE refnum;

	if (GetAppDir(PramFile)) {
		strcat(PramFile, "vMac.PRAM");

		refnum = CreateFile(
			PramFile, /* pointer to name of the file */
			GENERIC_READ, /* access (read-write) mode */
			FILE_SHARE_READ, /* share mode */
			nullpr, /* pointer to security descriptor */
			OPEN_EXISTING, /* how to create */
			FILE_ATTRIBUTE_NORMAL, /* file attributes */
			nullpr /* handle to file with attributes to copy */
		);
		if (refnum != INVALID_HANDLE_VALUE) {
			if (MyReadDat(refnum, PARAMRAMSize, PARAMRAM)) {
				PARAMRAMloaded = trueblnr;
			}
			(void) CloseHandle(refnum);
		}
	}

	if (PARAMRAMloaded) {
		HogCPU = PARAMRAM[20];
		SpeedLimit = PARAMRAM[21];
	}

	return trueblnr; /* keep going, even if couldn't load */
}

static void RTC_Save0 (void)
{
	char PramFile[_MAX_PATH];
	HANDLE refnum;

	if (PARAMRAMloaded) {
		PARAMRAM[20] = HogCPU;
		PARAMRAM[21] = SpeedLimit;

		if (GetAppDir(PramFile)) {
			strcat(PramFile, "vMac.PRAM");

			refnum = CreateFile(
				PramFile, /* pointer to name of the file */
				GENERIC_READ + GENERIC_WRITE, /* access (read-write) mode */
				0, /* share mode */
				nullpr, /* pointer to security descriptor */
				CREATE_ALWAYS, /* how to create */
				FILE_ATTRIBUTE_NORMAL, /* file attributes */
				nullpr /* handle to file with attributes to copy */
			);
			if (refnum != INVALID_HANDLE_VALUE) {
				MyWriteDat(refnum, PARAMRAMSize, PARAMRAM);
				(void) FlushFileBuffers(refnum);
				(void) CloseHandle(refnum);
			}
		}
	}
}

/*
	The function jdate was found at the end of the file
	webalizer.c in the program webalizer at
	"http://www.mrunix.net/webalizer/".
	Here is copyright info from the top of that file:	

	webalizer - a web server log analysis program

	Copyright (C) 1997-2000  Bradford L. Barrett (brad@mrunix.net)

	This program is free software; you can redistribute it and/or modify
	it under the terms of the GNU General Public License as published by
	the Free Software Foundation; either version 2 of the License, or
	(at your option) any later version, and provided that the above
	copyright and permission notice is included with all distributed
	copies of this or derived software.
*/

/*****************************************************************/
/*                                                               */
/* JDATE  - Julian date calculator                               */
/*                                                               */
/* Calculates the number of days since Jan 1, 0000.              */
/*                                                               */
/* Originally written by Bradford L. Barrett (03/17/1988)        */
/* Returns an unsigned long value representing the number of     */
/* days since January 1, 0000.                                   */
/*                                                               */
/* Note: Due to the changes made by Pope Gregory XIII in the     */
/*       16th Centyry (Feb 24, 1582), dates before 1583 will     */
/*       not return a truely accurate number (will be at least   */
/*       10 days off).  Somehow, I don't think this will         */
/*       present much of a problem for most situations :)        */
/*                                                               */
/* Usage: days = jdate(day, month, year)                         */
/*                                                               */
/* The number returned is adjusted by 5 to facilitate day of     */
/* week calculations.  The mod of the returned value gives the   */
/* day of the week the date is.  (ie: dow = days % 7 ) where     */
/* dow will return 0=Sunday, 1=Monday, 2=Tuesday, etc...         */
/*                                                               */
/*****************************************************************/

ULONG jdate( int day, int month, int year )
{
	ULONG days;                      /* value returned */
	int mtable[] = {0,31,59,90,120,151,181,212,243,273,304,334};

	/* First, calculate base number including leap and Centenial year stuff */

	days=(((ULONG)year*365)+day+mtable[month-1]+
		((year+4)/4) - ((year/100)-(year/400)));

	/* now adjust for leap year before March 1st */

	if ((year % 4 == 0) && !((year % 100 == 0) &&
		(year % 400 != 0)) && (month < 3))
	{
		--days;
	}

	/* done, return with calculated value */

	return(days+5);
}


ULONG GetMacDateInSecond(void)
{
	SYSTEMTIME s;
	ULONG curjdate;
	ULONG basejdate;

	GetLocalTime(&s);

	curjdate = jdate(s.wDay, s.wMonth, s.wYear);
	basejdate = jdate(1, 1, 1904);
	return (((curjdate - basejdate) * 24 + s.wHour) * 60
			+ s.wMinute) * 60 + s.wSecond;
}

static void MySetRegKey(HKEY hKeyRoot, char *strRegKey, char *strRegValue)
{
	HKEY RegKey;
	DWORD dwDisposition;

	if (RegCreateKeyEx(hKeyRoot, strRegKey, 0, NULL,
		REG_OPTION_NON_VOLATILE, KEY_ALL_ACCESS,
		NULL,&RegKey, &dwDisposition) == ERROR_SUCCESS)
	{
		RegSetValueEx(RegKey, NULL, 0, REG_SZ, strRegValue, strlen(strRegValue) + sizeof(char));
		RegCloseKey(RegKey);
	}
}

static void RegisterShellFileType (char *AppPath, char *strFilterExt,
	char *strFileTypeId, char *strFileTypeName,
	char *strIconId, blnr CanOpen)
{
	char strRegKey[_MAX_PATH];
	char strRegValue[_MAX_PATH + 2]; /* extra room for ","{strIconId} */

	MySetRegKey(HKEY_CLASSES_ROOT, strFileTypeId, strFileTypeName);
	MySetRegKey(HKEY_CLASSES_ROOT, strFilterExt, strFileTypeId);

	strcpy(strRegKey, strFileTypeId);
	strcat(strRegKey, "\\DefaultIcon");
	strcpy(strRegValue, AppPath);
	strcat(strRegValue, ",");
	strcat(strRegValue, strIconId);
	MySetRegKey(HKEY_CLASSES_ROOT, strRegKey, strRegValue);

	if (CanOpen) {
		strcpy(strRegKey, strFileTypeId);
		strcat(strRegKey, "\\shell\\open\\command");
		strcpy(strRegValue, AppPath);
		strcat(strRegValue, " \"%1\"");
		MySetRegKey(HKEY_CLASSES_ROOT, strRegKey, strRegValue);
	}
}

static blnr RegisterInRegistry(void)
{
	char AppPath[_MAX_PATH];

	GetModuleFileName(NULL, AppPath, _MAX_PATH);
	GetShortPathName(AppPath, AppPath, _MAX_PATH);

	RegisterShellFileType(AppPath, ".DSK", "minivmac.DSK", "Mini vMac Disk Image", "1", trueblnr);
	RegisterShellFileType(AppPath, ".ROM", "minivmac.ROM", "Mini vMac ROM Image", "2", falseblnr);

	return trueblnr;
}

static char *CommandLine;

static blnr ScanCommandLine(void)
{
	char fileName[_MAX_PATH];
	char *filePtr;
	blnr fPrint = falseblnr;
	char *p = CommandLine;

	while (*p != 0) {
		if (*p == ' ') {
			p++;
		} else {
			filePtr = fileName;
			if (*p == '\"') {
				p++;
				while (*p != '\"' && *p != 0) {
					*filePtr++ = *p++;
				}
				if (*p == '\"') {
					p++;
				}
			} else {
				while (*p != ' ' && *p != 0) {
					*filePtr++ = *p++;
				}
			}
			*filePtr = (char)0;
			Sony_Insert1(fileName);
		}
	}

	return trueblnr;
}

static BOOL APIENTRY MyWinDlgProc(
	HWND hDlg,
	WORD message,
	WORD wParam,
	LONG lParam)
{
	if (message == WM_COMMAND) {
		if (LOWORD(wParam) == IDCANCEL) {
			EndDialog(hDlg, TRUE);
			return TRUE;
		} else {
			return FALSE;
		}
	} else if (message == WM_INITDIALOG) {
		SetDlgItemText(hDlg, ID_ABOUT_VERSION, "Mini vMac 0.1.2, Copyright 2001.");
		SetDlgItemText(hDlg, ID_ABOUT_AUTHORS, "Including or based upon code by Bernd Schmidt, Philip Cummins, Richard F. Bannister, Weston Pawlowski, Paul Pratt, and others.");
		SetDlgItemText(hDlg, ID_ABOUT_LICENSE, "Mini vMac is distributed under the terms of the GNU Public License, version 2.");
		SetDlgItemText(hDlg, ID_ABOUT_WARRNTY, "Mini vMac is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.");
		SetDlgItemText(hDlg, ID_ABOUT_FORINFO, "For more information, see:");
		SetDlgItemText(hDlg, ID_ABOUT_WEBPAGE, "http://www.gryphel.com/c/minivmac");
		return TRUE;
	} else {
		return FALSE;
	}
	UNREFERENCED_PARAMETER(lParam);
}

static void ShowAboutAlert(void)
{
	(void) DialogBox(AppInstance,
		MAKEINTRESOURCE(IDD_MYABOUTDIALOG),
		MainWnd,
		(DLGPROC)MyWinDlgProc);
}

static blnr gBackgroundFlag = falseblnr;

LRESULT CALLBACK Win32WMProc(HWND MainWnd, UINT uMessage, WPARAM wparam, LPARAM lparam)
{
	switch (uMessage)
	{
		case WM_MOUSEMOVE:
			/* windows may have messed up cursor */
			/*
				there is no notification when the mouse moves
				outside the window, and the cursor is automatically
				changed
			*/
			if (! HaveCursorHidden) {
				/* SetCursor(LoadCursor(NULL,IDC_ARROW)); */
			}
			break;
		case WM_PAINT:
			{
				PAINTSTRUCT ps;

				BeginPaint(MainWnd, (LPPAINTSTRUCT)&ps);
				Screen_DrawAll();
				EndPaint(MainWnd, (LPPAINTSTRUCT)&ps);
			}
			break;

		case WM_SYSKEYDOWN:
			if(wparam==VK_F4) { //Alt F4
				RequestMacOff = trueblnr;
			}

#if KeyConfig == 3
		   {
			if(wparam==VK_SHIFT)
			 {KeyMod|=0x0200;
			  Keyboard_UpdateKeyMap(0x38, trueblnr);}

			if(wparam==VK_CAPITAL)
			 {KeyMod|=0x0400;
			  Keyboard_UpdateKeyMap(0x39, trueblnr);}

			if(wparam==VK_CONTROL)
			 {KeyMod|=0x1000; //Control
			  Keyboard_UpdateKeyMap(0x3b, trueblnr);}

			if(TestBit(lparam,24))
			{
				//Right Alt
				KeyMod|=0x0800; //Option
				Keyboard_UpdateKeyMap(0x3a, trueblnr);
			}
			else
			{
				//Left Alt
				KeyMod|=0x0100; //Command
				Keyboard_UpdateKeyMap(0x37, trueblnr);
			}

			KeyDown=1;
			wparam=Win32KeyRemap(wparam, KeyMod);
			if(wparam==0)
				break;
			Keyboard_Down(wparam | ((ULONG)KeyMod << 16));
		   }
#endif

#if KeyConfig == 2
		   {
			if(wparam==VK_CONTROL)
			 {KeyMod|=0x0800; //Option
			  Keyboard_UpdateKeyMap(0x3a, trueblnr);}

			if(wparam==VK_SHIFT)
			 {KeyMod|=0x0200;
			  Keyboard_UpdateKeyMap(0x38, trueblnr);}

			if(wparam==VK_CAPITAL)
			 {KeyMod|=0x0400;
			  Keyboard_UpdateKeyMap(0x39, trueblnr);}

			KeyMod|=0x0100; //Command
			Keyboard_UpdateKeyMap(0x37, trueblnr);

			KeyDown=1;
			wparam=Win32KeyRemap(wparam, KeyMod);
			if(wparam==0)
				break;
			Keyboard_Down(wparam | ((ULONG)KeyMod << 16));
		   }
#endif

			break;

		case WM_SYSKEYUP:
			if(wparam==VK_F4) //Alt F4
				RequestMacOff = trueblnr;

#if KeyConfig == 3
		   {
			if(wparam==VK_SHIFT)
			 {KeyMod&=~0x0200;
			  Keyboard_UpdateKeyMap(0x38, falseblnr);}

			if(wparam==VK_CAPITAL)
			 {KeyMod&=~0x0400;
			  Keyboard_UpdateKeyMap(0x39, falseblnr);}

			if(wparam==VK_CONTROL)
			 {KeyMod&=~0x1000; //Control
			  Keyboard_UpdateKeyMap(0x3b, falseblnr);}

			if(TestBit(lparam,24))
			{
				//Right Alt
				KeyMod&=~0x0800; //Option
				Keyboard_UpdateKeyMap(0x3a, falseblnr);
			}
			else
			{
				//Left Alt
				KeyMod&=~0x0100; //Command
				Keyboard_UpdateKeyMap(0x37, falseblnr);
			}

			KeyDown=1;
			wparam=Win32KeyRemap(wparam, KeyMod);
			if(wparam==0)
				break;
			Keyboard_Up(wparam | ((ULONG)KeyMod << 16));
		   }
#endif

#if KeyConfig == 2
		   {
			if(wparam==VK_CONTROL)
			 {KeyMod&=~0x0800; //Option
			  Keyboard_UpdateKeyMap(0x3a, falseblnr);}

			if(wparam==VK_SHIFT)
			 {KeyMod&=~0x0200;
			  Keyboard_UpdateKeyMap(0x38, falseblnr);}

			if(wparam==VK_CAPITAL)
			 {KeyMod&=~0x0400;
			  Keyboard_UpdateKeyMap(0x39, falseblnr);}

			KeyMod&=~0x0100; //Command
			Keyboard_UpdateKeyMap(0x37, falseblnr);

			KeyDown=0;
			wparam=Win32KeyRemap(wparam, KeyMod);
			if(wparam==0)
				break;
			Keyboard_Up(wparam | ((ULONG)KeyMod << 16));
		   }
#endif
			break;

		case WM_KEYDOWN:
			switch(wparam)
			{
			   case VK_CONTROL:
#if KeyConfig == 3
				   {
					KeyMod|=0x1000; //Control
					Keyboard_UpdateKeyMap(0x3b, trueblnr);
					break;
				   }
#endif

#if KeyConfig == 2
				   {
					KeyMod|=0x0800; //Option
					Keyboard_UpdateKeyMap(0x3a, trueblnr);
					break;
				   }
#endif

				  if(TestBit(lparam,24))
				  {
					//Right Control
#if KeyConfig == 1
					if(thePrefs.KeyConfig==1)
					{
						KeyMod|=0x0800; //Option
						Keyboard_UpdateKeyMap(0x3a, trueblnr);
					}
#endif
				  }
				  else
				  {
					//Left Control
#if KeyConfig == 1
					 {KeyMod|=0x0100; //Command
					  Keyboard_UpdateKeyMap(0x37, trueblnr);}
#endif
				  }

					break;

				case VK_SHIFT:
					KeyMod |= 0x0200;
					Keyboard_UpdateKeyMap(0x38, trueblnr);
					break;

				case VK_CAPITAL:
					KeyMod |= 0x0400;
					Keyboard_UpdateKeyMap(0x39, trueblnr);
					break;

				default:
					KeyDown = 1;
					wparam = Win32KeyRemap(wparam, KeyMod);
					if(wparam==0) {
						break;
					}
					Keyboard_Down(wparam | ((ULONG)KeyMod << 16));
					break;
			}
			break;

		case WM_KEYUP:
			switch(wparam) {
				case VK_CONTROL:
#if KeyConfig == 3
				   {
					KeyMod&=~0x1000; //Control
					Keyboard_UpdateKeyMap(0x3b, falseblnr);
					break;
				   }
#endif

#if KeyConfig == 2
				   {
					KeyMod&=~0x0800; //Option
					Keyboard_UpdateKeyMap(0x3a, falseblnr);
					break;
				   }
#endif

				  if(TestBit(lparam,24))
				  {
					//Right Control
#if KeyConfig == 1
					 {KeyMod&=~0x0800; //Option
					  Keyboard_UpdateKeyMap(0x3a, falseblnr);}
#endif
				  }
				  else
				  {
					//Left Control
#if KeyConfig == 1
					 {KeyMod&=~0x0100; //Command
					  Keyboard_UpdateKeyMap(0x37, falseblnr);}
#endif
				  }

				  break;

				case VK_SHIFT:
					KeyMod &= ~0x0200;
					Keyboard_UpdateKeyMap(0x38, falseblnr);
					break;

				case VK_CAPITAL:
					KeyMod &= ~0x0400;
					Keyboard_UpdateKeyMap(0x39, falseblnr);
					break;

				default:
					KeyDown = 0;
					wparam = Win32KeyRemap(wparam, KeyMod);
					if (wparam == 0) {
						break;
					}
					Keyboard_Up(wparam | ((ULONG)KeyMod << 16));
					break;
			}
			break;
		case WM_CLOSE:
			RequestMacOff = trueblnr;
			break;
		case WM_ACTIVATE:
			{
				blnr NewBackgroundFlag = (LOWORD(wparam) == WA_INACTIVE);
				if (NewBackgroundFlag != gBackgroundFlag) {
					gBackgroundFlag = NewBackgroundFlag;
					if (gBackgroundFlag) {
						ForceShowCursor();
					}
				}
			}
			break;
		case WM_COMMAND:
			switch(LOWORD(wparam))
			{
				case ID_FILE_INSERTDISK1:
					InsertADisk();
					break;
				case ID_FILE_QUIT:
					RequestMacOff = trueblnr;
					break;
				case ID_CONTROL_SHARETIME:
					/* HogCPU = ! HogCPU; */
					MacMsg("Not Implemented.", "Share Time cannot be turned off in this version of Mini vMac.", falseblnr);
					break;
				case ID_CONTROL_LIMITSPEED:
					SpeedLimit = ! SpeedLimit;
					break;
				case ID_CONTROL_RESET:
					RequestMacReset = trueblnr;
					break;
				case ID_CONTROL_INTERRUPT:
					RequestMacInterrupt = trueblnr;
					break;
				case ID_HELP_ABOUT:
					ShowAboutAlert();
					/* MacMsg(kStrAboutTitle, kStrAboutMessage, falseblnr); */
					break;
			}
			break;
		case WM_INITMENU:
			{
				HMENU CurMenuHdl = GetMenu(MainWnd);
				(void) CheckMenuItem(CurMenuHdl,
					ID_CONTROL_SHARETIME,
					MF_BYCOMMAND + MF_CHECKED);
				(void) CheckMenuItem(CurMenuHdl,
					ID_CONTROL_LIMITSPEED,
					MF_BYCOMMAND + (SpeedLimit ? MF_CHECKED : MF_UNCHECKED));
			}
			break;
		case WM_MOVE:
			WndX=(LONG) LOWORD(lparam);
			WndY=(LONG) HIWORD(lparam);
			break;
		case WM_SYSCHAR:
		case WM_CHAR:
		case WM_LBUTTONDOWN:
		case WM_LBUTTONUP:
		case WM_RBUTTONDOWN:
		case WM_RBUTTONUP:
			/* prevent any further processing */
			break;
		default:
			return DefWindowProc(MainWnd, uMessage, wparam, lparam);
	}
	return 0;
}

static blnr RegisterOurClass(void)
{
	WNDCLASS wc;

	wc.style         = CS_HREDRAW|CS_VREDRAW|CS_OWNDC;
	wc.lpfnWndProc   = (WNDPROC)Win32WMProc;
	wc.cbClsExtra    = 0;
	wc.cbWndExtra    = 0;
	wc.hInstance     = AppInstance;
	wc.hIcon         = LoadIcon(AppInstance, MAKEINTRESOURCE(IDI_VMAC));
	wc.hCursor       = LoadCursor(NULL,IDC_ARROW);
	wc.hbrBackground = (HBRUSH) (SS_WHITERECT);
	wc.lpszMenuName  = NULL;
	wc.lpszClassName = WndClassName;

	if (! RegisterClass((LPWNDCLASS)&wc.style)) {
		MacMsg("RegisterClass failed", "Sorry, vMac encountered errors and cannot continue.", trueblnr);
		return falseblnr;
	} else {
		return trueblnr;
	}
}

static void DoOnEachSixtieth(void)
{
	MSG msg;
	blnr GotMessage;

	CheckMouseState();
	do {

		if (gBackgroundFlag) {
			GotMessage = (GetMessage(&msg,NULL,0,0) != -1);
		} else {
			GotMessage = PeekMessage(&msg,NULL,0,0, PM_REMOVE);
		}
		if (GotMessage) {
			DispatchMessage(&msg);
		}
	} while (gBackgroundFlag);
		/*
			When in background, halt the emulator by
			continuously running the event loop
		*/
}

static DWORD LastTime;
static ULONG TimeCounter = 0;

static blnr Init60thCheck(void)
{
	LastTime = GetTickCount();
	return trueblnr;
}

blnr CheckIntSixtieth(blnr overdue)
{
	DWORD LatestTime;

	do {
		LatestTime = GetTickCount();
		if (LatestTime != LastTime) {
			TimeCounter += 60 * (LatestTime - LastTime);
			LastTime = LatestTime;
			if (TimeCounter > 1000) {
				TimeCounter %= 1000;
				/*
					Idea is to get here every
					1000/60 milliseconds, on average.
					Unless emulation has been interupted
					too long, which is why use '%='
					and not '-='.

				*/
				DoOnEachSixtieth();
				return trueblnr;
			}
		}
	} while (SpeedLimit && overdue);
	return falseblnr;
}

static void ZapOSGLUVars(void)
{
	ROM = NULL;
	RAM = NULL;
	screencomparebuff = NULL;
	MainWnd = NULL;
	MainWndDC = NULL;
	InitDrives();
}

static blnr InitOSGLU(void)
{
	if (RegisterOurClass())
	if (ScanCommandLine())
#if InstallFileIcons
	if (RegisterInRegistry())
#endif
	if (RTC_Load())
	if (AllocateMacROM())
	if (LoadMacRom())
	if (AllocateScreenCompare())
	if (CreateMainWindow())
	if (AllocateMacRAM()) /* do near end, so can have idea of how much space is left */
	if (InitTheCursor())
	if (Init60thCheck())
	{
		return trueblnr;
	}
	return falseblnr;
}

static void UnInitOSGLU(void)
{
	ForceShowCursor();

	RTC_Save0();

	if (RAM != NULL) {
		if (GlobalFree(RAM) != NULL) {
			MacMsg("error", "GlobalFree failed", falseblnr);
		}
	}

	if (MainWndDC != NULL) {
		ReleaseDC(MainWnd,MainWndDC);
	}
	if (MainWnd != NULL) {
		DestroyWindow(MainWnd);
	}
	if (screencomparebuff != NULL) {
		if (GlobalFree(screencomparebuff) != NULL) {
			MacMsg("error", "GlobalFree failed", falseblnr);
		}
	}
	if (ROM != NULL) {
		if (GlobalFree(ROM) != NULL) {
			MacMsg("error", "GlobalFree failed", falseblnr);
		}
	}
}

int WINAPI WinMain(HINSTANCE hInstance, HINSTANCE hPrevInstance, LPSTR lpCmdLine, int nCmdShow)
{
	UnusedParam(hPrevInstance);
	AppInstance = hInstance;
	CmdShow = nCmdShow;
	CommandLine = lpCmdLine;

	ZapOSGLUVars();
	if (InitOSGLU()) {
		ProgramMain();
	}
	UnInitOSGLU();

	return(0);
}

#endif /* WinTarget */
